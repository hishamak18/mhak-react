{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/hishamak/Desktop/mhak-react/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/hishamak/Desktop/mhak-react/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/home/hishamak/Desktop/mhak-react/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/home/hishamak/Desktop/mhak-react/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/home/hishamak/Desktop/mhak-react/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FetchHttpClientResponse = exports.FetchHttpClient = void 0;\nvar HttpClient_js_1 = require(\"./HttpClient.js\");\n/**\n * HTTP client which uses a `fetch` function to issue requests.\n *\n * By default relies on the global `fetch` function, but an optional function\n * can be passed in. If passing in a function, it is expected to match the Web\n * Fetch API. As an example, this could be the function provided by the\n * node-fetch package (https://github.com/node-fetch/node-fetch).\n */\nvar FetchHttpClient = /*#__PURE__*/function (_HttpClient_js_1$Http) {\n  _inherits(FetchHttpClient, _HttpClient_js_1$Http);\n  function FetchHttpClient(fetchFn) {\n    var _this;\n    _classCallCheck(this, FetchHttpClient);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FetchHttpClient).call(this));\n    _this._fetchFn = fetchFn;\n    return _this;\n  }\n  /** @override. */\n  _createClass(FetchHttpClient, [{\n    key: \"getClientName\",\n    value: function getClientName() {\n      return 'fetch';\n    }\n  }, {\n    key: \"makeRequest\",\n    value: function makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {\n      var isInsecureConnection = protocol === 'http';\n      var url = new URL(path, \"\".concat(isInsecureConnection ? 'http' : 'https', \"://\").concat(host));\n      url.port = port;\n      // For methods which expect payloads, we should always pass a body value\n      // even when it is empty. Without this, some JS runtimes (eg. Deno) will\n      // inject a second Content-Length header. See https://github.com/stripe/stripe-node/issues/1519\n      // for more details.\n      var methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';\n      var body = requestData || (methodHasPayload ? '' : undefined);\n      var fetchFn = this._fetchFn || fetch;\n      var fetchPromise = fetchFn(url.toString(), {\n        method: method,\n        // @ts-ignore\n        headers: headers,\n        // @ts-ignore\n        body: body\n      });\n      // The Fetch API does not support passing in a timeout natively, so a\n      // timeout promise is constructed to race against the fetch and preempt the\n      // request, simulating a timeout.\n      //\n      // This timeout behavior differs from Node:\n      // - Fetch uses a single timeout for the entire length of the request.\n      // - Node is more fine-grained and resets the timeout after each stage of\n      //   the request.\n      //\n      // As an example, if the timeout is set to 30s and the connection takes 20s\n      // to be established followed by 20s for the body, Fetch would timeout but\n      // Node would not. The more fine-grained timeout cannot be implemented with\n      // fetch.\n      var pendingTimeoutId;\n      var timeoutPromise = new Promise(function (_, reject) {\n        pendingTimeoutId = setTimeout(function () {\n          pendingTimeoutId = null;\n          reject(HttpClient_js_1.HttpClient.makeTimeoutError());\n        }, timeout);\n      });\n      return Promise.race([fetchPromise, timeoutPromise]).then(function (res) {\n        return new FetchHttpClientResponse(res);\n      }).finally(function () {\n        if (pendingTimeoutId) {\n          clearTimeout(pendingTimeoutId);\n        }\n      });\n    }\n  }]);\n  return FetchHttpClient;\n}(HttpClient_js_1.HttpClient);\nexports.FetchHttpClient = FetchHttpClient;\nvar FetchHttpClientResponse = /*#__PURE__*/function (_HttpClient_js_1$Http2) {\n  _inherits(FetchHttpClientResponse, _HttpClient_js_1$Http2);\n  function FetchHttpClientResponse(res) {\n    var _this2;\n    _classCallCheck(this, FetchHttpClientResponse);\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(FetchHttpClientResponse).call(this, res.status, FetchHttpClientResponse._transformHeadersToObject(res.headers)));\n    _this2._res = res;\n    return _this2;\n  }\n  _createClass(FetchHttpClientResponse, [{\n    key: \"getRawResponse\",\n    value: function getRawResponse() {\n      return this._res;\n    }\n  }, {\n    key: \"toStream\",\n    value: function toStream(streamCompleteCallback) {\n      // Unfortunately `fetch` does not have event handlers for when the stream is\n      // completely read. We therefore invoke the streamCompleteCallback right\n      // away. This callback emits a response event with metadata and completes\n      // metrics, so it's ok to do this without waiting for the stream to be\n      // completely read.\n      streamCompleteCallback();\n      // Fetch's `body` property is expected to be a readable stream of the body.\n      return this._res.body;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this._res.json();\n    }\n  }], [{\n    key: \"_transformHeadersToObject\",\n    value: function _transformHeadersToObject(headers) {\n      // Fetch uses a Headers instance so this must be converted to a barebones\n      // JS object to meet the HttpClient interface.\n      var headersObj = {};\n      var _iterator = _createForOfIteratorHelper(headers),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var entry = _step.value;\n          if (!Array.isArray(entry) || entry.length != 2) {\n            throw new Error('Response objects produced by the fetch function given to FetchHttpClient do not have an iterable headers map. Response#headers should be an iterable object.');\n          }\n          headersObj[entry[0]] = entry[1];\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return headersObj;\n    }\n  }]);\n  return FetchHttpClientResponse;\n}(HttpClient_js_1.HttpClientResponse);\nexports.FetchHttpClientResponse = FetchHttpClientResponse;","map":null,"metadata":{},"sourceType":"script"}