{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/hishamak/Desktop/mhak-react/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/home/hishamak/Desktop/mhak-react/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/home/hishamak/Desktop/mhak-react/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"/home/hishamak/Desktop/mhak-react/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/home/hishamak/Desktop/mhak-react/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NodeHttpClientResponse = exports.NodeHttpClient = void 0;\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar HttpClient_js_1 = require(\"./HttpClient.js\");\nvar defaultHttpAgent = new http.Agent({\n  keepAlive: true\n});\nvar defaultHttpsAgent = new https.Agent({\n  keepAlive: true\n});\n/**\n * HTTP client which uses the Node `http` and `https` packages to issue\n * requests.`\n */\nvar NodeHttpClient = /*#__PURE__*/function (_HttpClient_js_1$Http) {\n  _inherits(NodeHttpClient, _HttpClient_js_1$Http);\n  function NodeHttpClient(agent) {\n    var _this;\n    _classCallCheck(this, NodeHttpClient);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeHttpClient).call(this));\n    _this._agent = agent;\n    return _this;\n  }\n  /** @override. */\n  _createClass(NodeHttpClient, [{\n    key: \"getClientName\",\n    value: function getClientName() {\n      return 'node';\n    }\n  }, {\n    key: \"makeRequest\",\n    value: function makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {\n      var isInsecureConnection = protocol === 'http';\n      var agent = this._agent;\n      if (!agent) {\n        agent = isInsecureConnection ? defaultHttpAgent : defaultHttpsAgent;\n      }\n      var requestPromise = new Promise(function (resolve, reject) {\n        var req = (isInsecureConnection ? http : https).request({\n          host: host,\n          port: port,\n          path: path,\n          method: method,\n          agent: agent,\n          headers: headers,\n          ciphers: 'DEFAULT:!aNULL:!eNULL:!LOW:!EXPORT:!SSLv2:!MD5'\n        });\n        req.setTimeout(timeout, function () {\n          req.destroy(HttpClient_js_1.HttpClient.makeTimeoutError());\n        });\n        req.on('response', function (res) {\n          resolve(new NodeHttpClientResponse(res));\n        });\n        req.on('error', function (error) {\n          reject(error);\n        });\n        req.once('socket', function (socket) {\n          if (socket.connecting) {\n            socket.once(isInsecureConnection ? 'connect' : 'secureConnect', function () {\n              // Send payload; we're safe:\n              req.write(requestData);\n              req.end();\n            });\n          } else {\n            // we're already connected\n            req.write(requestData);\n            req.end();\n          }\n        });\n      });\n      return requestPromise;\n    }\n  }]);\n  return NodeHttpClient;\n}(HttpClient_js_1.HttpClient);\nexports.NodeHttpClient = NodeHttpClient;\nvar NodeHttpClientResponse = /*#__PURE__*/function (_HttpClient_js_1$Http2) {\n  _inherits(NodeHttpClientResponse, _HttpClient_js_1$Http2);\n  function NodeHttpClientResponse(res) {\n    var _this2;\n    _classCallCheck(this, NodeHttpClientResponse);\n    // @ts-ignore\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(NodeHttpClientResponse).call(this, res.statusCode, res.headers || {}));\n    _this2._res = res;\n    return _this2;\n  }\n  _createClass(NodeHttpClientResponse, [{\n    key: \"getRawResponse\",\n    value: function getRawResponse() {\n      return this._res;\n    }\n  }, {\n    key: \"toStream\",\n    value: function toStream(streamCompleteCallback) {\n      // The raw response is itself the stream, so we just return that. To be\n      // backwards compatible, we should invoke the streamCompleteCallback only\n      // once the stream has been fully consumed.\n      this._res.once('end', function () {\n        return streamCompleteCallback();\n      });\n      return this._res;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var _this3 = this;\n      return new Promise(function (resolve, reject) {\n        var response = '';\n        _this3._res.setEncoding('utf8');\n        _this3._res.on('data', function (chunk) {\n          response += chunk;\n        });\n        _this3._res.once('end', function () {\n          try {\n            resolve(JSON.parse(response));\n          } catch (e) {\n            reject(e);\n          }\n        });\n      });\n    }\n  }]);\n  return NodeHttpClientResponse;\n}(HttpClient_js_1.HttpClientResponse);\nexports.NodeHttpClientResponse = NodeHttpClientResponse;","map":null,"metadata":{},"sourceType":"script"}