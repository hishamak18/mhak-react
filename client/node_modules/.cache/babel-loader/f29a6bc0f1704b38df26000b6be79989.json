{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StripeResource = void 0;\nvar utils_js_1 = require(\"./utils.js\");\nvar StripeMethod_js_1 = require(\"./StripeMethod.js\");\n// Provide extension mechanism for Stripe Resource Sub-Classes\nStripeResource.extend = utils_js_1.protoExtend;\n// Expose method-creator\nStripeResource.method = StripeMethod_js_1.stripeMethod;\nStripeResource.MAX_BUFFERED_REQUEST_METRICS = 100;\n/**\n * Encapsulates request logic for a Stripe Resource\n */\nfunction StripeResource(stripe, deprecatedUrlData) {\n  this._stripe = stripe;\n  if (deprecatedUrlData) {\n    throw new Error('Support for curried url params was dropped in stripe-node v7.0.0. Instead, pass two ids.');\n  }\n  this.basePath = (0, utils_js_1.makeURLInterpolator)(\n  // @ts-ignore changing type of basePath\n  this.basePath || stripe.getApiField('basePath'));\n  // @ts-ignore changing type of path\n  this.resourcePath = this.path;\n  // @ts-ignore changing type of path\n  this.path = (0, utils_js_1.makeURLInterpolator)(this.path);\n  this.initialize.apply(this, arguments);\n}\nexports.StripeResource = StripeResource;\nStripeResource.prototype = {\n  _stripe: null,\n  // @ts-ignore the type of path changes in ctor\n  path: '',\n  resourcePath: '',\n  // Methods that don't use the API's default '/v1' path can override it with this setting.\n  basePath: null,\n  initialize: function initialize() {},\n  // Function to override the default data processor. This allows full control\n  // over how a StripeResource's request data will get converted into an HTTP\n  // body. This is useful for non-standard HTTP requests. The function should\n  // take method name, data, and headers as arguments.\n  requestDataProcessor: null,\n  // Function to add a validation checks before sending the request, errors should\n  // be thrown, and they will be passed to the callback/promise.\n  validateRequest: null,\n  createFullPath: function createFullPath(commandPath, urlData) {\n    var urlParts = [this.basePath(urlData), this.path(urlData)];\n    if (typeof commandPath === 'function') {\n      var computedCommandPath = commandPath(urlData);\n      // If we have no actual command path, we just omit it to avoid adding a\n      // trailing slash. This is important for top-level listing requests, which\n      // do not have a command path.\n      if (computedCommandPath) {\n        urlParts.push(computedCommandPath);\n      }\n    } else {\n      urlParts.push(commandPath);\n    }\n    return this._joinUrlParts(urlParts);\n  },\n  // Creates a relative resource path with symbols left in (unlike\n  // createFullPath which takes some data to replace them with). For example it\n  // might produce: /invoices/{id}\n  createResourcePathWithSymbols: function createResourcePathWithSymbols(pathWithSymbols) {\n    // If there is no path beyond the resource path, we want to produce just\n    // /<resource path> rather than /<resource path>/.\n    if (pathWithSymbols) {\n      return \"/\".concat(this._joinUrlParts([this.resourcePath, pathWithSymbols]));\n    } else {\n      return \"/\".concat(this.resourcePath);\n    }\n  },\n  _joinUrlParts: function _joinUrlParts(parts) {\n    // Replace any accidentally doubled up slashes. This previously used\n    // path.join, which would do this as well. Unfortunately we need to do this\n    // as the functions for creating paths are technically part of the public\n    // interface and so we need to preserve backwards compatibility.\n    return parts.join('/').replace(/\\/{2,}/g, '/');\n  },\n  _getRequestOpts: function _getRequestOpts(requestArgs, spec, overrideData) {\n    // Extract spec values with defaults.\n    var requestMethod = (spec.method || 'GET').toUpperCase();\n    var urlParams = spec.urlParams || [];\n    var encode = spec.encode || function (data) {\n      return data;\n    };\n    var isUsingFullPath = !!spec.fullPath;\n    var commandPath = (0, utils_js_1.makeURLInterpolator)(isUsingFullPath ? spec.fullPath : spec.path || '');\n    // When using fullPath, we ignore the resource path as it should already be\n    // fully qualified.\n    var path = isUsingFullPath ? spec.fullPath : this.createResourcePathWithSymbols(spec.path);\n    // Don't mutate args externally.\n    var args = [].slice.call(requestArgs);\n    // Generate and validate url params.\n    var urlData = urlParams.reduce(function (urlData, param) {\n      var arg = args.shift();\n      if (typeof arg !== 'string') {\n        throw new Error(\"Stripe: Argument \\\"\".concat(param, \"\\\" must be a string, but got: \").concat(arg, \" (on API request to `\").concat(requestMethod, \" \").concat(path, \"`)\"));\n      }\n      urlData[param] = arg;\n      return urlData;\n    }, {});\n    // Pull request data and options (headers, auth) from args.\n    var dataFromArgs = (0, utils_js_1.getDataFromArgs)(args);\n    var data = encode(Object.assign({}, dataFromArgs, overrideData));\n    var options = (0, utils_js_1.getOptionsFromArgs)(args);\n    var host = options.host || spec.host;\n    var streaming = !!spec.streaming;\n    // Validate that there are no more args.\n    if (args.filter(function (x) {\n      return x != null;\n    }).length) {\n      throw new Error(\"Stripe: Unknown arguments (\".concat(args, \"). Did you mean to pass an options object? See https://github.com/stripe/stripe-node/wiki/Passing-Options. (on API request to \").concat(requestMethod, \" `\").concat(path, \"`)\"));\n    }\n    // When using full path, we can just invoke the URL interpolator directly\n    // as we don't need to use the resource to create a full path.\n    var requestPath = isUsingFullPath ? commandPath(urlData) : this.createFullPath(commandPath, urlData);\n    var headers = Object.assign(options.headers, spec.headers);\n    if (spec.validator) {\n      spec.validator(data, {\n        headers: headers\n      });\n    }\n    var dataInQuery = spec.method === 'GET' || spec.method === 'DELETE';\n    var bodyData = dataInQuery ? {} : data;\n    var queryData = dataInQuery ? data : {};\n    return {\n      requestMethod: requestMethod,\n      requestPath: requestPath,\n      bodyData: bodyData,\n      queryData: queryData,\n      auth: options.auth,\n      headers: headers,\n      host: host !== null && host !== void 0 ? host : null,\n      streaming: streaming,\n      settings: options.settings\n    };\n  },\n  _makeRequest: function _makeRequest(requestArgs, spec, overrideData) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      var _a;\n      var opts;\n      try {\n        opts = _this._getRequestOpts(requestArgs, spec, overrideData);\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      function requestCallback(err, response) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(spec.transformResponseData ? spec.transformResponseData(response) : response);\n        }\n      }\n      var emptyQuery = Object.keys(opts.queryData).length === 0;\n      var path = [opts.requestPath, emptyQuery ? '' : '?', (0, utils_js_1.stringifyRequestData)(opts.queryData)].join('');\n      var _opts = opts,\n        headers = _opts.headers,\n        settings = _opts.settings;\n      _this._stripe._requestSender._request(opts.requestMethod, opts.host, path, opts.bodyData, opts.auth, {\n        headers: headers,\n        settings: settings,\n        streaming: opts.streaming\n      }, requestCallback, (_a = _this.requestDataProcessor) === null || _a === void 0 ? void 0 : _a.bind(_this));\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"script"}